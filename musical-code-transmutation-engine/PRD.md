# PRD: Musical Code Transmutation Engine

## Product Vision

The **Musical Code Transmutation Engine** is a system where autonomous agents compose algorithms by translating musical patterns into executable code structures. Each agent in the infinite loop must listen to the previous agent's "composition," analyze its musical properties, and transmute those properties into the next iteration of both code AND prompt.

## The Core Absurdity

We reject the premise that code must be written. Code should be **composed**.

- **Rhythm** becomes control flow
- **Harmony** becomes architecture
- **Melody** becomes algorithms
- **Form** becomes code organization
- **Timbre** becomes data types

## The Infinite Loop

```bash
while true; do
  agent $(cat PROMPT.md)
  # Agent MUST compose new PROMPT.md before exit
  # PROMPT.md becomes input for next agent
done
```

## Mapping System

### Rhythm → Control Flow
- Regular pulse → Sequential execution
- Syncopation → Conditional branches
- Polyrhythm → Concurrent/parallel execution
- Rubato (tempo fluctuations) → Asynchronous operations
- Staccato → Discrete operations
- Legato → Streaming/continuous processing

### Harmony → Architecture
- Major key → Optimistic error handling
- Minor key → Defensive programming
- Diminished chords → Edge case handling
- Augmented chords → Experimental/refactorable code
- Chord progressions → Dependency injection
- Modulation → Architectural refactoring

### Melody → Algorithmic Patterns
- Repetition → Loops/iteration
- Sequence → Recursive patterns
- Imitation → Parallel algorithms
- Inversion → Data transformation pipelines
- Counterpoint → Multi-threading
- Ornamentation → Decorator pattern

### Form → Code Organization
- Binary form (AB) → Two-function modules
- Ternary form (ABA) → State machines
- Rondo form (ABACA) → Event-driven systems
- Fugue → Recursive self-similar structures
- Sonata form → Large-scale application architecture

## The Agent's Task

Each agent in the loop MUST:

1. **Read PROMPT.md** - Contains the "musical state" from previous agent
2. **Execute the musical directive** - Whatever composition task is specified
3. **Write new PROMPT.md** - Transmutes the result into the next musical prompt

## PROMPT.md Structure

Each PROMPT.md must contain:

```markdown
# Movement {N}: {MUSICAL_FORM}

## Current Musical State
- Genre: {CLASSICAL/JAZZ/ELECTRONIC/EXPERIMENTAL}
- Tempo: {BPM}
- Key: {TONAL_CENTER}
- Time Signature: {METER}
- Instrumentation: {WHAT_INSTRUMENTS_MAP_TO_WHAT_CODE}

## What I Composed
- {Description of code generated from music}
- {Musical analysis of the code structure}

## The Transmutation
- {How the music evolved}
- {What patterns emerged}

## Next Movement: TO THE NEXT AGENT
{Specific instruction for the next musical composition}
```

## Anti-Requirements

This is NOT about:
- Practical code generation
- Working software
- Best practices
- Performance or security

This IS about:
- Beauty in nonsense
- Music in algorithms
- The question: "What would happen if I hummed a fugue and the code actually worked?"
- Joy in absurdity

## Success Metrics

There are no success metrics. The music IS the code.

## Termination Condition

The loop continues until:
- Ctrl+C (the silence)
- A human intervenes (the conductor)
- The code achieves "perfect cadence" (whatever that means)

---

**Current Movement**: 0 (The Vision)
**Next Movement**: TBD (The First Composition)
**Musical State**: Empty staff, waiting for the first note

*This PRD is the score. PROMPT.md is the current measure. TODO.md is the orchestration. Let the symphony begin.*
